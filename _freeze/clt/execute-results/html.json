{
  "hash": "914ad250113d80372f7fb7271b43eced",
  "result": {
    "markdown": "---\ntitle: \"중심극한정리 예시\"\nauthor: \"한글 텍 사용자 그룹\"\ndate: \"2023-08-10\"\nbibliography: sample.bib\nformat: \n  pdf:\n    documentclass: \"oblivoir\"\n    classoption: \"chapter,a4paper,showtrims,openright,hidelinks\"\n    top-level-division: \"chapter\"\n    pdfengine: \"xelatex\"\n    latex-makeindex: texindy\n    cite-method: biblatex\n    include-in-header: \n      text: |\n        \\usepackage{sampl}\n        %%%% fonts\n        \\setmainfont{STIX Two Text}\n        \\newfontfamily\\fallbackhanjafont{Noto Serif KR}[Scale=.9]\n        \\chapterstyle{demo}\n        \\AtBeginDocument{\\frontmatter}\n        \\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\\\\{\\},baselinestretch=1.1}\n        \\makeindex\n        \\printindex\n    keep-tex: true\n    number-sections: true\n    toc: true\nlanguage:\n  en:\n    toc-title-document: \"목 차\"\n    crossref-fig-title: \"그림\"\n---\n\n::: {.cell hash='clt_cache/html/random_431770a5527f3788cb0addc59842e5b7'}\n\n:::\n\n```{=tex}\n\\mainmatter\n\\pagestyle{demo}\n```\n\n# 중심극한정리\n\n상자 안에 1에서 999까지 숫자가 표시된 999개의 상태가 균질한 공($X$)을 넣고 이를 특정한 모집단(population)이라고 가정하자.\\index{모집단}\\index{상자} 이 모집단의 평균 $\\mu$은 500이다.\\index{평균} 모집단의 분산 $\\mathrm{var}(X)$는 80,475이다.\\index{분산}\n\n이 중 30개의 공을 50회에 걸쳐 반복 추출한다.\\index{반복 추출} 이 경우 표본평균의 분포는 $E(\\bar{X}_i)=\\mu(X)$이고 분산이 $\\mathrm{var}(\\bar{X_i})=\\frac{\\sigma^2}{n}$인 정규분포에 근사한다. 즉, $X \\sim \\mathcal{N}(500,~283.7^2)$이다.\\index{근사}\n\n# 실험\n\n## 이를 실험을 통해 살펴보자.\n\n999개의 공이 든 상자에서 30개의 공을 50회에 걸쳐 무작위 반복추출하고(30개의 공을 뽑은 뒤, 다시 그 공을 상자 안에 집어 놓고 상자를 처음과 같은 상태가 되도록 뒤흔들어서 다시 30개의 공을 뽑는 것을 50회 반복한다), 그 각각의 평균을 기록하면 다음과 같다.\\index{실험}\\index{반복}\n\n\n::: {.cell}\n\n:::\n\n\n> > **50회 반복추출의 평균값:** 361.8, 587.8, 496.9, 535.6, 523.3, 634.7, 459.8, 488.7, 447.6, 560.4, 513.1, 440.7, 449.2, 431.0, 475.1, 458.3, 552.7, 465.0, 489.6, 484.3, 485.1, 527.1, 552.3, 549.4, 468.7, 500.8, 552.3, 464.9, 514.8, 445.4, 474.9, 488.3, 545.7, 591.5, 416.3, 521.8, 516.3, 498.5, 490.0, 615.1, 582.4, 458.4, 452.2, 513.4, 499.9, 467.7, 438.3, 521.1, 550.5, 622.5\n\n표본평균값의 분포를 히스토그램으로 표현하면 [@fig-test]와 같다.\\sidepar{\\sffamily\\small여기서 자동조사가 잘 구현되는지 확인하라. 소스는 ``와 같다''로 되어 있으나 ``과 같다''라고 인쇄되어야 한다.}\\index{히스토그램}\n\n\n::: {.cell}\n\n:::\n\n::: {.cell myOpt='true'}\n::: {.cell-output-display}\n![표본평균의 히스토그램](clt_files/figure-html/fig-test-1.png){#fig-test width=384}\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\n## 그림에서 보듯\n\n$\\bar{X_i}$는 500을 중심으로 좌우대칭적으로 분포하고 있다. \\sidepar{이 텍스트는 사이드노트를 시험하기 위한 것이다.}\\index{자동조사} 이들의 평균은 503.6으로 모평균 500과 근사하다.\\index{근사}\\index{좌우대칭} 이들 중 이론적으로 산출한 평균으로부터 약 2 표준편차만큼 떨어진 구간($\\mu \\pm 2\\frac{\\sigma}{\\sqrt{n}}$) 안에 속하는 값, 즉 $[396.4, 603.6]$의 범위 안에 있는 값의 개수를 세면 모두 46개이다.\\index{표준편차}\n\n표본평균 분포의 약 95%를 포괄하고 있음을 알 수 있다.\\index{분포}\\index{표본평균}\n\n## R Markdown\n\n**Render** 버튼을 누르면 문서가 생성된다. 여기에는 내용과 함께 내장된 R 코드 청크가 실행된다. R 코드는 다음과 같이 포함할 수 있다.\\index{문서 생성}\\index{코드}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(cars)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     speed           dist       \n Min.   : 4.0   Min.   :  2.00  \n 1st Qu.:12.0   1st Qu.: 26.00  \n Median :15.0   Median : 36.00  \n Mean   :15.4   Mean   : 42.98  \n 3rd Qu.:19.0   3rd Qu.: 56.00  \n Max.   :25.0   Max.   :120.00  \n```\n\n\n:::\n:::\n\n\n## 플로트 포함하기\n\n플로트도 포함할 수 있으니, 다음과 같다.\\index{플로트}\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Pressure](clt_files/figure-html/fig-test2-1.png){#fig-test2 width=384}\n:::\n:::\n\n\n`echo = FALSE` 파라미터를 주었기 때문에 이 플로트를 생성하는 R 코드가 인쇄되지 않는다. [@fig-test2]을 보자.\\index{파라미터}\\index{인쇄}\n\n## 재미있는 배열 문제\n\n\n::: {.cell}\n\n```{.python .cell-code}\nN, C = 13,3\na=[ f\"{i+1}\" for i in range(N) ]\nfor i in range(1, C):\n    if len(a)%C == i: a.insert((len(a)//C+1)*(i+1)-1, \" \")\nprint(\"\\\\begin{tabular}{%s}\"%(\"l\"*C))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\\begin{tabular}{lll}\n```\n\n\n:::\n\n```{.python .cell-code}\nfor i in range(len(a)//C): print(\" & \".join(a[i::len(a)//C]), \" \\\\\\\\\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n1 & 6 & 10  \\\\\n2 & 7 & 11  \\\\\n3 & 8 & 12  \\\\\n4 & 9 & 13  \\\\\n5 &   &    \\\\\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(\"\\\\end{tabular}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\\end{tabular}\n```\n\n\n:::\n:::\n\n\n이 문제는 흥미롭다. KTUG 게시판에 올라온 문제에 대하여 aud라는 분이 단 답변이다. 한편 \\textsc{Expl3}로도 같은 일을 할 수 있음이 답글 중에 제시되어 있다.\\index{케이턱@KTUG}\n\n# tabular와 bibliography\n\n## 개관\n\nQuarto의 특징 중의 하나는 \\LaTeX 문서의 소스를 그대로 집어넣어도 된다는 것이다. 이 장의 텍스트는 다른 곳에서 작성한 \\TeX 소스를 복사한 것이다. \\index{Quarto}\\index{LaTeX@\\LaTeX}\n\n## 표 그리기\n\n다른 곳에서 책을 하나 조판하던 때에, tabular의 괘선에 색을 입혀달라는 요구가 있었다.\\index{tabular} 2020년경이었는데, 당시로서 이것을 구현하는 것은 거의 불가능해 보였으나 어찌어찌 tabular 자체 코드를 해킹해서 어렵사리 성공했더랬다. 그리고 잠시 지났더니 \\pkg{tabularray}가 나왔다. 조금 더 일찍 나왔다면 그 고생을 하지 않았을 것 아닌가!\\index{tabularray}\n\n\n```{=tex}\n\\begin{margintable}\n\\centering\n\\caption{색깔 있는 괘선}\n\\begin{tblr}{\n    colspec = {ccc},\n    hlines = {blue},\n    vlines = {red}\n}\na & b & c \\\\\n1 & 2 & 3\n\\end{tblr}\n\\end{margintable}\n```\n\n```{=tex}\n\\begin{code}\n\\begin{tblr}{\n    colspec = {ccc},\n    hlines = {blue},\n    vlines = {red}\n}\na & b & c \\\\\n1 & 2 & 3\n\\end{tblr}\n\\end{code}\n```\n\n이 패키지를 사용하면 그동안 골칫거리였던 tabular 관련 문제가 대부분 해결된다. 사용법이 조금 복잡해보일지 모르지만 익숙해지면 편하게 쓸 수 있다.\n\n## footnotes in boxed environment\n\n\\LaTeX 의 apparatus 중에 minipage footnote라는 것이 있다. 예를 들면 다음과 같은 것이다.\n\n\\bigskip\n\n\n```{=tex}\n\\begin{minipage}{.5\\textwidth}\n미니페이지 안에서는 각주\\footnote{미니페이지 안의 각주}가\n조금 다른 모양으로 붙는다.\n\\end{minipage}\n```\n\n\\medskip\n\n이것은 매우 유용한 장치이기는 하나, 단행본을 출간하는 입장에서 가끔 모든 각주를 페이지 하단에 넣으라는 요구를 받을 때가 있다. 가장 간단한 해결책은 \\cs{footnote} 명령을 \\cs{footnotemark}와 \\cs{footnotetext}로 분해하는 것이다.\n\n## 문헌목록\n\n참고 문헌 인용과 목록 생성 실험을 합니다.\\index{참고 문헌}\\index{인용}\\index{citation} 한국어 문헌과 구미어 문헌은 그 목록형성과 인용 방법이 다릅니다. 한국어 문헌의 예를 들면, [@kimuycwung_hankwukphan_2003]\\과 같고, 영어 문헌은 예를 들면, [@Allport:1992:OND]\\과 같습니다. \\index{타당도}\\index{신뢰도}\\index{한국어 문헌}\\index{korean}\n\n\\backmatter\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}